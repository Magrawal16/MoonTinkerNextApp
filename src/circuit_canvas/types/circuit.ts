// using ids for connections to allow for easier serialization and deserialization
// test
export type CircuitElement = {
  id: string;
  x: number;
  y: number;
  rotation?: number; // rotation angle in degrees (0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330)
  nodes: Node[];
  connecters?: ElementConnecter[];
  type: string;

  properties?: {
    voltage?: number; // for power sources like batteries
    resistance?: number; // all components can have resistance
    ratio?: number; // for potentiometers, the ratio of resistance
    mode?: "voltage" | "current" | "resistance"; // multimeter modes: V, A, Î©
    distance?: number; // cm
    temperature?: number;
    brightness?: number;
    color?: string;
    gesture?: string;
    // For 1.5V battery form factor (AA or AAA) to mirror Tinkercad UI
    batteryType?: "AA" | "AAA";
    // For battery count (1-4 batteries in series) to mirror Tinkercad UI
    batteryCount?: number;
    // For notes
    text?: string; // note text content
    width?: number; // note width
    height?: number; // note height
    backgroundColor?: string; // note background color
    collapsed?: boolean; // note collapsed state
  };
  computed?: {
    current?: number; // computed current through the element
    voltage?: number; // computed voltage across the element
    power?: number; // computed power consumed or generated by the element
    measurement?: number; // Specific reading for multimeter
    forwardVoltage?: number; // anode-to-cathode voltage used for diodes/LEDs
    reverseVoltage?: number; // cathode-to-anode voltage magnitude
    shorted?: boolean; // Fault flag (e.g., micro:bit 3.3V-GND short)
    // For failed components that are opened in the main solver (e.g., exploded LED),
    // we can optionally provide a "what-if" current computed by solving the same
    // circuit as-if the device were still electrically intact. Used to match
    // Tinkercad-style readouts for direct-to-source scenarios.
    explosionCurrentEstimate?: number;
  };
  controller?: {
    [key: string]: unknown;
    leds?: number[][];
    pins?: Record<string, { digital?: number; analog?: number }>; // <-- analog added
    temperature?: number;
    brightness?: number;
    logoTouched?: boolean; // <-- optional snapshot of logo state
  };
  wires?: Wire[];
  displayProperties?: string[];
  runtime?: {
    led?: LedRuntimeState;
    [key: string]: unknown;
  };
};

export type Wire = {
  toNodeId: string;
  fromNodeId: string;
  id: string;
  resistance?: number;
  color?: string; // Optional color for the wire
  joints: { x: number; y: number }[];
  hidden?: boolean; // When true, treated as connection but not rendered (node-to-node)
  deleted?: boolean; // When true, wire is marked for deletion and should not be in circuit
};

export type Node = {
  id: string;
  x: number;
  y: number;
  parentId: string;
  polarity?: "positive" | "negative"; // Optional polarity for the node
  placeholder?: string;
  fillColor?: string;
};

export type ElementConnecter = {
  id: string;
  parentId: string;
  x: number;
  y: number;
  state?: string;
};

export type LedVisualState = "off" | "on" | "hot" | "exploded";

export interface LedRuntimeState {
  brightness: number; // 0..1 visual brightness
  thermalEnergy: number; // accumulated abuse energy (arb. units)
  exploded: boolean;
  pendingExplosionAt?: number; // epoch ms when the LED will explode
  smokeStartedAt?: number; // epoch ms when smoke animation should begin
  failureReason?: "reverse" | "overcurrent" | "overpower";
  visualState: LedVisualState;
  flickerSeed: number; // stable seed for flicker/noise
  lastUpdateAt?: number;
  explosionCurrent?: number; // current at time of explosion
}

export type Size =
  | { width: number; height: number; radius?: never }
  | { radius: number; width?: never; height?: never };

// ...existing code...

export type CircuitElementProps = {
  type: string;
  idNumber: number;
  pos: { x: number; y: number };
  rotation?: number;
  properties?: {
    resistance?: number;
    voltage?: number;
    ratio?: number;
    temperature?: number;
    brightness?: number;
    color?: string;
    text?: string;
    width?: number;
    height?: number;
    backgroundColor?: string;
    collapsed?: boolean;
  };
};

export type PaletteElementType =
  | "lightbulb"
  | "battery"
  | "cell3v"
  | "AA_battery"
  | "powersupply"
  | "resistor"
  | "multimeter"
  | "potentiometer"
  | "led"
  | "microbit"
  | "ultrasonicsensor4p"
  | "microbitWithBreakout"
  | "note";

export type PropertiesPanelProps = {
  selectedElement: CircuitElement | null;
  wires: Wire[];
  getNodeById: (id: string) => Node | undefined;
  onElementEdit: (
    updatedElement: CircuitElement,
    deleteElement: boolean
  ) => void;
  onWireEdit: (updatedWire: Wire, deleteElement: boolean) => void;
  onEditWireSelect?: (wire: Wire) => void;
  // ...existing code...
  setOpenCodeEditor: (open: boolean) => void;
  wireColor?: string;
};

// ----------------------
// Microbit-specific types
// ----------------------

// Controller input now supports the logo touch sensor:
export type ControllerInput =
  | "A"
  | "B"
  | "AB"
  | { type: "logo"; state: "pressed" | "released" }
  | { type: "button"; button: "A" | "B" | "AB"; state: "pressed" | "released" };

export interface MicrobitProps {
  id: string;
  x: number;
  y: number;
  selected?: boolean;

  // Accepts buttons and the logo touch sensor
  onControllerInput?: (input: ControllerInput) => void;

  leds: number[][][];

  // Allow analog alongside digital to match simulator capabilities
  pins: Record<string, { digital?: number; analog?: number }>;

  isSimulationOn?: boolean;

  // Fault flags from solver (e.g., direct 3V-to-GND short)
  isShorted?: boolean;
}

export interface BaseElementProps {
  id: string;
  x: number;
  y: number;
  selected?: boolean;
  draggable?: boolean;
}
